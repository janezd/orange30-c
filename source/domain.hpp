/*
    This file is part of Orange.
    
    Copyright 1996-2010 Faculty of Computer and Information Science, University of Ljubljana
    Contact: janez.demsar@fri.uni-lj.si

    Orange is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Orange is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Orange.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __DOMAIN_HPP
#define __DOMAIN_HPP

/*! Classes and definitions related to domains. */
#include "domain.ppp"

/// Type to hold the attribute index.
typedef int TAttrIdx;

/*! Returns a new meta id.
    \see getMetaId(PVariable const &)
*/
inline long getMetaID()
{
    static TMetaId metaID = -1;
    return --metaID; 
}

/*! Returns a meta id suitable for the given variable.
    If the variable has been already registered in a domain
    as a meta attribute with some id, that id is returned.
    Otherwise, a new id is generated by #getMetaID() and returned,
    but not stored in #TVariable::defaultMetaId.
    \see TVariable::defaultMetaId
    \see getMetaID()
*/ 
inline long getMetaID(PVariable const &var)
{
    return var && var->defaultMetaId ? var->defaultMetaId : getMetaID(); 
}

/// @cond Python
PYMODULEFUNCTION PyObject *newmetaid(PyObject *, PyObject *args, PyObject *kw) PYARGS(METH_BOTH, "([variable]) -> int");
/// @endcond

/*! Descriptor for meta attributes registered in the domain */
class TMetaDescriptor {
public:
    TMetaId id; ///< Id of the meta attribute
    PVariable variable; ///< Descriptor for the meta attribute
    int optional; ///< Indicates that the attribute is optional

    TMetaDescriptor();
    TMetaDescriptor(TMetaId const ai, PVariable const &avar, int const opt = 0);
    TMetaDescriptor(const TMetaDescriptor &);
    TMetaDescriptor &operator =(const TMetaDescriptor &);

    /* We don't need this, but need to provide it to be able to export the class to a DLL*/
    bool operator <(const TMetaDescriptor &other) const  { return id < other.id; }
    bool operator ==(const TMetaDescriptor &other) const  { return id == other.id; }
};


/*! A vector of meta attributes registered in the domain */
class TMetaVector : public vector<TMetaDescriptor> {
public:
    TMetaDescriptor *operator[](PVariable const &);
    TMetaDescriptor const *operator[](PVariable const &) const;
    TMetaDescriptor *operator[](string const &);
    TMetaDescriptor const *operator[](string const &) const;
    TMetaDescriptor *operator[](TMetaId const);
    TMetaDescriptor const *operator[](TMetaId const) const;
};


/*! Description of the domain. The object stores the descriptors, it
    contains methods for finding a descriptor with a certain name or
    index and vice versa, and converts examples from another domain.

    Descriptors are stored in two lists; attributes and class(es) are
    stored together in a list #variables, and separately in
    #attributes and #classVar. Domain also contains a list of
    registered meta attributes and a version number that is unique for
    each instance and changes whenever the domain is changed.

    All variables must be primitive (that is, #TDiscreteVariable or
   #TContinuousVariable). Meta attributes can be of any type.
*/

class TDomain : public TOrange {
public:
    __REGISTER_CLASS(Domain);

    /// Class variable; may be NULL
    PVariable classVar; //PR The class variable (`Orange.data.variable.Variable`), or None if there is none. Read only.

    /// A list of attributes, excluding the class
    PVarList attributes; //PR(+features) List of domain attributes (`Orange.data.variable.Variables`) without the class variable. Read only.

    /// A list of attributes, including the class
    PVarList variables; //PR List of domain attributes (`Orange.data.variable.Variables`) including the class variable. Read only.

    /*! Indicates that the domain can be converted to/from any other domain
        with the same attribute types. Such domains are used for example tables
        that are constructed automatically from numpy arrays. */ 
    bool anonymous; //PR True if domain can be converted into any other domain with the same attribute types
    
    /*! Registered meta attributes */
    TMetaVector metas;

    /*! A unique int identifying the domain. The version changed whenever
        the #classVar, #attributes or #variables is changed. Domain conversion
        and other functions that cache information computed from the domain
        (usually attribute indices) use this number to verify whether 
        the cached data is still valid. */
    int version; //PR unique version identifier; changed each time a domain is changed.

private:
    /*! A global counter of domain versions.
      \see #version */
    static int domainVersion;

public:
    TDomain();
    TDomain(PVariable const &, PVarList const &);
    TDomain(PVarList const &variables);
    TDomain(PVariable const &, TVarList const &);
    TDomain(TVarList const &variables);
    TDomain(TDomain const &);
    ~TDomain();

    /// A vector of attribute descriptions (#TVariable::TAttributeDescription)
    typedef vector<TVariable::TAttributeDescription> TAttributeDescriptions;

    bool makeCompatible(TAttributeDescriptions const *const attrdescs,
                        bool const hasClass,
                        TAttributeDescriptions const *const metadescs,
                        TMetaId *metaIDs = NULL);

    static PDomain prepareDomain(
        TAttributeDescriptions const *const attributes, bool const hasClass,
        TAttributeDescriptions const *const metas, int const createNewOn,
        PIntList &status, PIntIntList &metaStatus);

    static void checkPrimitive(TVarList const &, PVariable const &classVar = PVariable());

    TAttrIdx getVarNum(PVariable const &,
                       bool const throwExc=true) const;
    TAttrIdx getVarNum(string const &,
                       bool const throwExc=true) const;
    TAttrIdx getVarNum(PyObject *obj,
                       bool const throwExc=true) const;

    PVariable getVar(TAttrIdx const,
                     bool const throwExc=true) const;
    PVariable getVar(string const &,
                     bool const includeMetas=true,
                     bool const throwExc=true) const;
    PVariable getVar(PyObject *,
                     bool const includeMetas=true,
                     bool const throwExc=true,
                     bool const checkExistence=true) const;

    TMetaId getMetaNum(string const &,
                       bool const throwExc=true) const;
    TMetaId getMetaNum(PVariable const &,
                       bool const throwExc=true) const;
    TMetaId getMetaNum(PyObject *,
                       bool const throwExc=true,
                       bool const checkExistence=true) const;

    PVariable getMetaVar(TMetaId const,
                         bool const throwExc=true) const;
    PVariable getMetaVar(string const &,
                         bool const throwExc=true) const;
    PVariable getMetaVar(PyObject *,
                         bool const throwExc=true,
                         bool const checkExistence=true) const;

    inline PVariable operator[](const string &name) const;

    PVariable hasDiscreteAttributes(bool const checkClass = true) const;
    PVariable hasContinuousAttributes(bool const checkClass = true) const;

private:
    /*!  A mapping from one domain to another. The mapping caches the 
         attribute indices for conversions between domains. Instances of
         this class are created and used by method #convert.
    */
    class TDomainMapping {
    public:
        /*! The source domain to which the mapping refers. The class stores
            a plain pointer not a P-class to prevent reference counting and
            allow a domain to be garbage-collected even if it is still
            referenced (a domain is removed from the mapping by the destructor) */
        TDomain *const domain;

        /*!  Positions of attributes in the source domain. For instance,
             if position[2] equals 5, the value of the second attribute from
             the target domain is copied from the fifth attribute in the
             source domain. Negative values represent id's of the source
             domain's meta-attributes. If position is \c ILLEGAL_INT,
             the attribute in the target has no corresponding attribute in
             the source domain; the target attribute's #TVariable::computeValue
             method is used to copute the value from source example or
             return an undefined value if it can't. */
        vector<TAttrIdx> positions;

        /*! Similar to #positions, except that it holds data for meta
            attributes. The first index contains id in the target domain
            and the second is the index in the source. */
        vector<pair<TMetaId, TMetaId> > metaPositions;

        /*! Indices of meta attributes that appear in #positions or
            #metaPositions. Source meta attributes in this set are not
            copied as meta attributes of target examples. */
        set<TMetaId> metasNotToCopy;

        TDomainMapping(TDomain *const dom) : domain(dom) {};
    };

    /// Cached domain conversion mappings
    list<TDomainMapping> knownDomains;

    /// The pointer to the last used mapping
    list<TDomainMapping>::iterator lastDomain;

    /*! The list of domains which cache a mapping for conversion from
        this domain. The list is used for discarding the information
        when the domain is changed. 
        \todo This mechanism may be from before we had domain
        versions, and may be redundant. Perhaps it would suffice to remove the 
        domain from other domains's mapping when a domain is destructed.
        In any case, it probably does not need to send notices to knownDomains. */
    list<TDomain *> knownByDomains;

public:
    void domainHasChanged();
    void domainChangedDispatcher();
    void domainChangedNoticeHandler(TDomain *const);

    void convert(
        TExample *const dest, TExample const *const src,
        bool const skipMetas = false);

    void addToCRC(unsigned int &crc) const;
    unsigned int sumValues() const;

    int traverse_references(visitproc visit, void *arg);
    int clear_references();

    /// @cond Python

    TMetaDescriptor *metaDescriptorFromArg(PyObject *rar);
    inline TMetaDescriptor const *metaDescriptorFromArg(PyObject *rar) const;
    static PVariable varFromArg_byDomain(PyObject *, PDomain const &,
        bool const checkForIncludance=false, bool const noIndex=false,
        bool const throwExc=true);
    static PVariable varFromArg_byVarList(PyObject *, PVarList const &,
        bool const checkForIncludance=false, bool const noIndex=false);
    static bool varListFromVarList(PyObject *, PVarList const &source,
        PVarList &res, bool const allowSingle=true,
        bool const checkForIncludance=true);

    PyObject *getmetasLow() const;
    PyObject *getmetasLow(const int optional) const;
    static bool convertMetasFromPython(PyObject *dict, TMetaVector &metas);
    PyObject *addmetasLow(PyObject *dict, const int opt = 0);
    static bool removeMeta(PyObject *rar, TMetaVector &metas);

    static TOrange *__new__(PyTypeObject *type, PyObject *args, PyObject *kw) PYDOC("(attributes[, class_var, source, metas])");
    PyObject *__getnewargs__() const PYARGS(METH_NOARGS, "(); prepare arguments for unpickling");
    Py_ssize_t __len__() const;
    int __contains__(PyObject *arg) const;
    PyObject *__item__(Py_ssize_t index) const;
    PyObject *__subscript__(PyObject *index) const;
    PyObject *__repr__() const;
    PyObject *__str__() const;
    PyObject *__call__(PyObject *args, PyObject *kw) PYDOC("(instance) -> Instance");

    static PyObject *__get__columns(PyObject *self);

    PyObject *index(PyObject *arg) const PYARGS(METH_O, "(variable) -> int");
    PyObject *py_hasDiscreteAttributes (PyObject *args, PyObject *kw) const PYARGS(METH_BOTH, "(include_class=0) -> bool");
    PyObject *py_hasContinuousAttributes(PyObject *args, PyObject *kw) const PYARGS(METH_BOTH, "(include_class=0) -> bool");
    PyObject *checksum() const PYARGS(METH_NOARGS, "() -> crc");

    PyObject *meta_id(PyObject *rar) const PYARGS(METH_O, "(name | descriptor) -> int");
    PyObject *isOptionalMeta(PyObject *rar) const PYARGS(METH_O, "(name | id | descriptor) -> bool");
    PyObject *has_meta(PyObject *rar) const PYARGS(METH_O, "(name | id | descriptor) -> bool");
    PyObject *get_meta(PyObject *rar) const PYARGS(METH_O, "(name | id) -> Variable");
    PyObject *get_metas(PyObject *args, PyObject *kw) const PYARGS(METH_BOTH, "([optional]) -> {int: Variable}");
    PyObject *add_meta(PyObject *args, PyObject *kw) PYARGS(METH_BOTH, "(id, descriptor[, optional]) -> None");
    PyObject *add_metas(PyObject *args, PyObject *kw) PYARGS(METH_BOTH, "(meta_dict[, optional]) -> None");
    PyObject *remove_meta(PyObject *rar) PYARGS(METH_O, "({id0:desc0, id1:desc1, ...}) | ([id0|desc0, id1|desc1, ...]) -> None");

    /// @endcond
};


/// @cond Python
class TDataColumns : public TOrange {
public:
    __REGISTER_CLASS(DataColumns);
    PDomain domain; //PR domain
    TDataColumns(PDomain const &);
    PyObject *__getattr__(PyObject *name);

private:
    static bool matchesRenamedVar(string const &pyname, string const &varname);
};
/// @endcond

/// @cond Python
TMetaDescriptor const *TDomain::metaDescriptorFromArg(PyObject *rar) const
{
    return const_cast<TDomain *>(this)->metaDescriptorFromArg(rar);
}
/// @endcond


/*! Returns the descriptor for the variable or meta attribute with the given
    name
*/
PVariable TDomain::operator[](string const &name) const
{ 
    return getVar(name, true, true);
}

#endif
