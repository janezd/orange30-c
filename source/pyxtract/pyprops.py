#!/usr/bin/env python
import re, os, os.path, sys, pickle

if 1:
    specialmethods = [
                ("", "tp_name", ""),
                ("", "tp_basicsize", ""),
                ("", "tp_itemsize", ""),
                ("dealloc", "tp_dealloc", "destructor"),
                ("", "tp_print", ""),
                ("", "tp_getattr", ""),
                ("", "tp_setattr", ""),
                ("", "tp_reserved", ""),
                ("repr", "tp_repr", "reprfunc"),
                ("as_number", "tp_as_number", ""),
                ("", "tp_as_sequence", ""),
                ("", "tp_as_mapping", ""),
                ("hash", "tp_hash", "hashfunc"),
                ("call", "tp_call", "ternaryfunc"),
                ("str", "tp_str", "reprfunc"),
                ("getattr", "tp_getattro", "getattrofunc"),
                ("setattr", "tp_setattro", "setattrofunc"),
                ("", "tp_as_buffer", ""),
                ("", "tp_flags", ""),
                ("", "tp_doc", ""),
                ("traverse", "tp_traverse", "traverseproc"),
                ("clear", "tp_clear", "inquiry"),
                ("richcmp", "tp_richcmp", "richcmpfunc"),
                ("", "tp_weaklistoffset", ""),
                ("iter", "tp_iter", "getiterfunc"),
                ("iternext", "tp_iternext", "iternextfunc"),
                ("", "tp_methods", ""),
                ("", "tp_members", ""),
                ("", "tp_getset", ""),
                ("", "tp_base", ""),
                ("", "tp_dict", ""),
                ("", "tp_descrget", ""),
                ("", "tp_descrset", ""),
                ("", "tp_dictoffset", ""),
                ("init", "tp_init", "initproc"),
                ("", "tp_alloc", "PyType_GenericAlloc"),
                ("new", "tp_new", "newfunc"),
                ("free", "tp_free", "freefunc"),
                ("", "tp_is_gc", ""),
                ("", "tp_bases", ""),
                ("", "tp_mro", ""),
                ("", "tp_cache", ""),
                ("", "tp_subclasses", ""),
                ("", "tp_weaklist", "")
               ]

    specialnumericmethods = [
                ("add", "nb_add", "binaryfunc"),
                ("sub", "nb_subtract", "binaryfunc"),
                ("mul", "nb_multiply", "binaryfunc"),
                ("mod", "nb_remainder", "binaryfunc"),
                ("divmod", "nb_divmod", "binaryfunc"),
                ("pow", "nb_power", "ternaryfunc"),
                ("neg", "nb_negative", "unaryfunc"),
                ("pos", "nb_positive", "unaryfunc"),
                ("abs", "nb_absolute", "unaryfunc"),
                ("bool", "nb_bool", "inquiry"),
                ("inv", "nb_invert", "unaryfunc"),
                ("lshift", "nb_lshift", "binaryfunc"),
                ("rshift", "nb_rshift", "binaryfunc"),
                ("and", "nb_and", "binaryfunc"),
                ("xor", "nb_xor", "binaryfunc"),
                ("or", "nb_or", "binaryfunc"),
                ("int", "nb_int", "unaryfunc"),
                ("", "nb_long", "unaryfunc"),
                ("float", "nb_float", "unaryfunc"),
                ("oct", "nb_oct", "unaryfunc"),
                ("hex", "nb_hex", "unaryfunc")
                ]

    specialsequencemethods = [
                ("len", "sq_length", "lenfunc"),
                ("concat", "sq_concat", "binaryfunc"),
                ("repeat", "sq_repeat", "ssizeargfunc"),
                ("item", "sq_item", "ssizeargfunc"),
                ("", "was_sq_slice", "ssizessizeargfunc"),
                ("ass_item", "sq_ass_item", "ssizeobjargproc"),
                ("", "was_sq_ass_slice", "ssizessizeobjargproc"),
                ("contains", "sq_contains", "objobjproc"),
                ("inplace_concat", "sq_inplace_concat", "binaryfunc"),
                ("inplace_repeat", "sq_inplace_repeat", "indexargfunc")
                ]

    specialmappingmethods = [
                ("len", "mp_length", "lenfunc"),
                ("subscript", "mp_subscript", "binaryfunc"),
                ("ass_subscript", "mp_ass_subscript", "objobjargproc")
                ]

    specialnumericmethodslots = set(x[1] for x in specialnumericmethods)
    specialsequencemethodslots = set(x[1] for x in specialsequencemethods)
    specialmappingmethodslots = set(x[1] for x in specialmappingmethods)

    identifier2slot = dict(x[:2] for x in (
        specialmethods + specialnumericmethods +
        specialsequencemethods + specialmappingmethods) if x[0])
    
    notice = "/* This file has been generated by pyprops.py. Do not edit. */ \n\n"


    P_classTemplate = """
#ifndef Or%(classname)s_Check

class Or%(classname)s;
extern PyTypeObject Or%(classname)s_Type;
#define Or%(classname)s_Check(op) PyObject_TypeCheck(op, &Or%(classname)s_Type)
"""

    P_classTemplate_list_convert = """class T%(wrapped)s;
T%(wrapped)s *vector_convertPy(PyObject *obj, T%(wrapped)s **, bool &ok);
"""

    P_classTemplate_P = """
class T%(classname)s;
class P%(classname)s : public P%(parent)s
{
public:
    inline P%(classname)s() {};

    inline explicit P%(classname)s(T%(classname)s *const o)
    : P%(parent)s((T%(parent)s *const)o)
    {}

    inline static P%(classname)s fromBorrowedPtr(T%(classname)s *const o)
    {
        return (P%(classname)s)P%(parent)s::fromBorrowedPtr((T%(parent)s *const)o);
    }

    inline explicit P%(classname)s(PyObject *o)
    : P%(parent)s(o)
    {}

    inline P%(classname)s(P%(classname)s const &o)
    : P%(parent)s(o)
    {}

    explicit P%(classname)s(POrange const &o);

    template<class T> 
    inline static P%(classname)s cast(T const &o)
    {  return fromBorrowedPtr(dynamic_cast<T%(classname)s *>(o.orange));  }

    inline T%(classname)s *borrowPtr() const
    { return (T%(classname)s *)orange; }

    inline T%(classname)s *getPtr() const
    {
        incref();
        return (T%(classname)s *)orange;
    }

    inline T%(classname)s &operator *() const
    {
        checkNull();
        return *(T%(classname)s *)orange;
    }

    inline T%(classname)s *operator ->() const
    {
        checkNull();
        return (T%(classname)s *)orange;
    }

    static int argconverter(PyObject *obj, P%(classname)s *addr);
    static int argconverter_n(PyObject *obj, P%(classname)s *addr);
    static int setter(PyObject *whom, PyObject *mine, size_t *offset);
};
"""

    P_classTemplate_end = """
    #endif
"""
    
    Px_template_includes = """
#include "%(hppfile)s"
#include "structmember.h"
"""

    # for abstract classes, we just put TOrange here; doesn't matter, it won't ever get instantiated...
    Px_template_PyClass = """
class Or%(classname)s {
public:
    PyObject_HEAD;
    T%(classname_inpy)s orange;
};
"""

    Px_template_T_clone = """
T%(classname)s *T%(classname)s::clone() const
{ return new ((AS_PyObject(this))->ob_type) T%(classname)s(*this); }

void T%(classname)s::__dealloc__(Or%(classname)s *self)
{ delete &self->orange; }

int T%(classname)s::__traverse__(Or%(classname)s *self, visitproc visit, void *args)
{ return self->orange.traverse_references(visit, args); }

int T%(classname)s::__clear__(Or%(classname)s *self)
{ return self->orange.clear_references(); }
"""

    Px_template_T = ""

    Px_template_list_convert = """
T%(wrapped)s *vector_convertPy(PyObject *obj, const T%(wrapped)s **, bool &ok)
{
    if (!(ok = Or%(wrapped)s_Check(obj))) {
        PyErr_Format(PyExc_TypeError, "cannot convert '%%s' to '%(wrapped)s'", obj->ob_type->tp_name);
        return NULL;
    }
    return (T%(wrapped)s *)&((OrOrange *)obj)->orange;
}
"""

    Px_template_newer = """
PyObject *%(classname)s_newer(PyTypeObject *type, PyObject *args, PyObject *kw) {
    try {
        return Orange_GenericNewWithKeywords(
            type, T%(classname)s::__new__, args, kw, %(keywords)s);
    } PyCATCH
}
"""

    Px_template_new_with_call = """extern char *%(callBase)s_call_keywords[];

PyObject *%(classname)s_new_with_call(PyTypeObject *type, PyObject *args, PyObject *kw) {
    try {
        return Orange_GenericNewWithCall(
            new(type) T%(classname)s(), args, kw, %(callBase)s_call_keywords);
    } PyCATCH
}

"""

    Px_template_new_without_args = """PyObject *%(classname)s_new_without_args(PyTypeObject *type, PyObject *args, PyObject *kw) {
    try {
        return Orange_GenericNewWithoutArgs(new(type) T%(classname)s(), args, kw);
    } PyCATCH
}

"""

    Px_template_P = """
P%(classname)s::P%(classname)s(POrange const &o)
: P%(baseclass)s(o)
{ 
    if (o && !dynamic_cast<T%(classname)s *>(o.orange)) {
        raiseError(PyExc_SystemError, "invalid cast to '%(classname)s'");
    }
}

int P%(classname)s::argconverter(PyObject *obj, P%(classname)s *addr)
{
    if (!obj) {
        addr->clear();
    }
    else if (Or%(classname)s_Check(obj)) {
        *addr = P%(classname)s(obj);
    }
    else {
        T%(classname)s *o = (T%(classname)s *)T%(classname)s::setterConversion(obj);
        if (!o) {
            PyErr_Format(PyExc_TypeError,
                "cannot convert '%%s' to '%(classname)s'", obj->ob_type->tp_name);
            return 0;
        }  
        *addr = P%(classname)s(o);
    }
    return Py_CLEANUP_SUPPORTED;
}
    
int P%(classname)s::argconverter_n(PyObject *obj, P%(classname)s *addr)
{
    if (obj != Py_None) {
        return argconverter(obj, addr);
    }
    addr->clear();
    return Py_CLEANUP_SUPPORTED;
}

int P%(classname)s::setter(PyObject *whom, PyObject *mine, size_t *offset)
{
    try {
        bool not_null = (*offset & 0x4000000) != 0;
        const size_t real_offset = *offset & 0x1fffffff;
        P%(classname)s *fld = (P%(classname)s *)((char *)(whom)+real_offset);
        if (!mine || (mine == Py_None)) {
            if (not_null) {
                PyErr_Format(PyExc_ValueError, "attribute must not be None");
                return -1;
            }
            fld->clear();
            return 0;
        }
        else if (Or%(classname)s_Check(mine)) {
            *fld = P%(classname)s(mine);
        }
        else {
            T%(classname)s *o = (T%(classname)s *)T%(classname)s::setterConversion(mine);
            if (!o) {
                if (!PyErr_Occurred()) {
                    PyErr_Format(PyExc_TypeError,
                        "cannot convert '%%s' to '%(classname)s'",
                        mine->ob_type->tp_name);
                }
                return -1;
            }  
            *fld = P%(classname)s(o);
        }
        return 0;
    }
    PyCATCH_r(-1); 
}


"""

    namedConstantType_template = """
extern PyTypeObject %(typename)s;
extern TNamedConstantsDef %(constprefix)s_constList[];

PyObject *%(constprefix)s_repr(PyObject *self)
{ return get_constantName(self, %(constprefix)s_constList); }

static PyMethodDef %(constprefix)s_methods[] =
    { {"__reduce__", (PyCFunction)reduceNamedConstant, METH_NOARGS, NULL}, {NULL} };

PyTypeObject %(typename)s =
     {PyVarObject_HEAD_INIT(&PyType_Type, 0) "%(classname)s.%(consttype)s",
     sizeof(PyLongObject), 0, 0, 0, 0, 0, 0,
     (reprfunc)%(constprefix)s_repr, 0, 0, 0, 0, 0,
     (reprfunc)%(constprefix)s_repr,
     PyObject_GenericGetAttr, 0, 0,
     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_LONG_SUBCLASS, 0, 0, 0, 0, 0, 0, 0,
     %(constprefix)s_methods, 0, 0,
     &PyLong_Type, 0, 0, 0, 0, 0, 0, 0, 0};

"""

    init_template = """
#ifdef _MSC_VER
  #define WIN32_LEAN_AND_MEAN
  #include <windows.h>
  BOOL APIENTRY DllMain( HANDLE, DWORD  ul_reason_for_call, LPVOID)  { return TRUE; }
#endif

extern PyObject *%(modulename)sModule;

static struct PyModuleDef %(modulename)s_module_def = {
    PyModuleDef_HEAD_INIT,
    "%(modulename)s", /* m_base */
    NULL,
    0, /* size of state */
    %(methods)s, /* m_methods */
    NULL,  /* m_reload */
    NULL, /* traverse */
    NULL, /* clear */
    NULL  /* m_free - not needed, since all is done in m_clear */
};

extern "C" __declspec(dllexport) PyObject *PyInit_%(modulename)s()
{ 
  %(modulename)sModule = PyModule_Create(&%(modulename)s_module_def);
  if (!addObjects(%(modulename)sModule))
     return NULL;
  header_inits(%(modulename)sModule);
  return %(modulename)sModule;
}
"""


win32 = sys.platform == "win32"

f_underscored = open("pyxtract/_underscored", "a")
hump = re.compile("([a-z])([A-Z])")
def camel2underscore(s):
    if s[0].isupper():
        return s
    else:
        u = hump.sub(lambda mo: "%s_%s" % (mo.group(1),
                        mo.group(2).lower()
                           if mo.end() == len(s) or not 'A' <= s[mo.end()] <= 'Z'
                           else mo.group(2)), s)
        if u != s:
            f_underscored.write("%-40s %s\n" % (s, u))
        return u

class ClassDefinition:
    def __init__(self, name, parent, abstract=0):
        self.name = name
        self.parent = parent
        self.abstract = abstract
        self.methods = []
        self.members = []
        self.references = []
        self.getsetters = {}
        self.constants = {}
        self.imported = 0
        self.specialMethods = set()
        self.recognizedAttributes = set()
        self.slots = {}
        self.slotDoc = {}
        self.isList = False
        self.methodWrappers = []
        self.noPickling = False

class MethodDefinition:
    def __init__(self, methodname, cname, argkw, doc, wrapper=""):
        self.methodname = methodname
        self.argkw = argkw
        self.doc = doc
        self.cname = cname
        self.wrapper = wrapper

class GetSetterDefinition:
    def __init__(self, getter=0, setter=0, doc="",
                 cname="", closureDef="", closureName=""):
        self.getter = getter
        self.setter = setter
        self.doc = doc
        self.cname = cname
        self.closureDef = closureDef
        self.closureName = closureName

class ModuleData:
    def __init__(self):
        self.classes = []
        self.needsInit = False
        
        
memberTypes = dict((x, "T_" + x.upper())
                   for x in ("short", "int", "long", "float", "double", "char"))

memberTypes.update({"bool": "T_BOOL",
                    "TValue": "T_DOUBLE",
                    "TMetaId": "T_INT",
                    "TAttrIdx": "T_INT",
                    "PyObject *": "T_OBJECT_EX"})

noclasswarnings = []

def tf(x):
    return str(bool(x)).lower()

def samefiles(n1, n2):
    return open(n1, "rt").read() == open(n2, "rt").read()

def renew(off):
    off.close()
    newfile = off.name
    oldfile = newfile[:-4]
    oldexists = os.path.isfile(oldfile)
    if oldexists:
        if not samefiles(oldfile, newfile):
            os.remove(oldfile)
            os.rename(newfile, oldfile)
            print("Renewing " + oldfile)
        else:
            os.remove(newfile)
    else:
        os.rename(newfile, oldfile)
        print("Creating " + oldfile)


class PPParser:
    def __init__(self, hppfile):
        self.hppfile = hppfile
        try:
            self.cpp = open(hppfile[:-4] + ".cpp").read()
        except IOError:
            self.cpp = ""
        self.classes = {}
        self.classOrder = []
        self.headerInitCalls = ""
        self.needsInit = False
        self.moduleConstants = {}
        self.moduleFunctions = []
        self.lcount = 0

    def checkScope(self, currentClass, msg):
        if currentClass:
            return True
        if self.hppfile not in ("orvector.hpp", "orattributedvector.hpp", "valuelist.hpp"):
            print("%s(%i): Warning: %s out of scope. Ignoring." %
                  (self.hppfile, self.lcount + 1, msg))


    def storeClass(self, currentClass):
        if currentClass:
            self.classes[currentClass.name] = currentClass
            
    propbegindef = re.compile(r'\s*class\s+T(?P<name>\w+)\s*(:\s*public\s+(?P<parent>\w+))?')
    oranstuffdef = re.compile(r'\s*__REGISTER(?P<abstract>_ABSTRACT)?_CLASS')
    tdidtdef = re.compile('\s*DEFINEDESCENDER\s*\(\s*(?P<name>\w*)')
    callbackdef = re.compile('\s*((DEFINE_BUT_OPERATOR)|(DEFINE_CALLBACK))\s*\(\s*(?P<name>\w*)\s*,\s*(?P<parent>\w*)')
    def parse(self):
        ff = open(self.hppfile, "rt")
        istdidt = self.hppfile == "tdidt.hpp"
        iscallback = self.hppfile == "callback.hpp"

        currentClass = None
        candidate = candidateBase = ""
        for self.lcount, line in enumerate(ff):
            if "NOPYPROPS" in line:
                continue
            if istdidt:
                found = PPParser.tdidtdef.match(line)
                if found:
                    self.storeClass(currentClass)
                    currentClass = ClassDefinition(
                        "TTreeDescender_" + found.group("name"), "TreeDescender")
                    self.classOrder.append(currentClass.name)
                    continue
            if iscallback:
                found = PPParser.callbackdef.match(line)
                if found:
                    self.storeClass(currentClass)
                    continue

            found = PPParser.propbegindef.match(line)
            if found:
                candidate, candidateBase = found.group("name", "parent")
                if candidateBase:
                    candidateBase = candidateBase[1:]
                continue

            found = PPParser.oranstuffdef.match(line)
            if found and candidate:
                self.storeClass(currentClass)
                currentClass = self.classes.get(candidate, None)
                if not currentClass:
                    currentClass = ClassDefinition(
                        candidate, candidateBase, bool(found.group("abstract")))
                    self.classOrder.append(currentClass.name)
                continue

            for m in dir(self):
                if m.startswith("detect") and getattr(self, m)(currentClass, line):
                    break
        
        self.storeClass(currentClass)

    doccomment = re.compile(r'\s*/\*\s*(?P<docstring>.*?)\*/', re.DOTALL)
    def extractDoc(self, funcname):
        funcidx = self.cpp.find(funcname)
        if funcidx == -1:
            return None
        funcidx = self.cpp.find("\n", funcidx)
        if funcidx == -1:
            return None
        found = PPParser.doccomment.match(self.cpp, funcidx)
        if found:
            return found.group("docstring").strip()
        
    dictdef = re.compile(r'PyObject\s*\*(?P<name>\w+).*/\*\s*PYXTRACT:\s*dict_field\s*\*/')
    def detectDict(self, currentClass, line):
        found = PPParser.dictdef.search(line)
        if found:
            currentClass.slots["tp_dictoffset"] = \
                "offsetof(T%(classname)s, %(cname)s)+offsetof(Or%(classname)s, orange)" % \
                {"classname": currentClass.name, "cname": found.group("name")}
            return True
    
    propdef = re.compile(r'\s*(mutable)?\s*(?P<ctype>\w+)\s+(?P<cname>\w+)\s*;\s*//P(?P<flags>\w+)?\s*(\((?P<pnameflag>[>+])(?P<pname>\w+)\s*\))?(\(&(?P<proptype>\w+)\s*\))?(?P<pdesc>[^\r\n]*)')
    propwarndef = re.compile(r'\\\\P')
    def detectProperties(self, currentClass, line):
        found = PPParser.propdef.match(line)
        if found and self.checkScope(currentClass, "property definition"):
            ctype, cname, flags, pnameflag, pname, pdesc, proptype = \
                found.group("ctype", "cname", "flags", "pnameflag", "pname",
                            "pdesc", "proptype")
            if pnameflag == "+":
                truename = cname
            else:
                truename = pname or cname
            readonly = flags and "R" in flags
            classname = currentClass.name
            if proptype:
                if "." in proptype:
                    propclassname, proptype = proptype.split(".")
                else:
                    propclassname = classname
                closureDef = ("""extern TNamedConstantsDef %(propclassname)s_%(proptype)s_constList[];
                                 TNamedConstantsFieldClosure %(classname)s_%(cname)s_member_closure = {"""
                              + PPParser.offsettemplate +
                              ", %(propclassname)s_%(proptype)s_constList};") % vars()
                defn = GetSetterDefinition(
                    "getter_namedConstant",
                    "setter_namedConstant" if not readonly else 0, pdesc, cname,
                    closureDef= closureDef,
                    closureName="%(classname)s_%(cname)s_member_closure" % vars())
                currentClass.getsetters[truename] = defn
                if pnameflag == "+":
                    defn = GetSetterDefinition(
                        "getter_namedConstant",
                        "setter_namedConstant" if not readonly else 0, pdesc, cname,
                        closureName="%(classname)s_%(cname)s_member_closure" % vars())
                    currentClass.getsetters[pname] = defn
            elif ctype in memberTypes:
                currentClass.members.append((truename, memberTypes[ctype], cname, readonly, pdesc))
                if pnameflag == "+":
                    currentClass.members.append((pname, memberTypes[ctype], cname, readonly, pdesc))
            elif ctype == "string":
                closureDef = ("const size_t %(classname)s_%(cname)s_member_offset = "
                              + PPParser.offsettemplate + ";") % vars()
                defn = GetSetterDefinition(
                    "getter_string",
                    "setter_string" if not readonly else 0, pdesc, cname,
                    closureDef=closureDef,
                    closureName="%(classname)s_%(cname)s_member_offset" % vars())
                currentClass.getsetters[truename] = defn
                if pnameflag == "+":
                    defn = GetSetterDefinition(
                        "getter_string",
                        "setter_string" if not readonly else 0, pdesc, cname,
                        closureName="%(classname)s_%(cname)s_member_offset" % vars())
                    currentClass.getsetters[pname] = defn
            elif ctype[0] == "P":
                flags = ""
                if "N" in flags:
                    flags += "+0x40000000"
                closureDef = "const size_t T%s_%s_member_offset = " % \
                             (classname, cname) + \
                             PPParser.offsettemplate % vars() + flags + ";"
                defn = GetSetterDefinition(
                    "getter_orange",
                    (ctype + "::setter") if not readonly else 0, pdesc, cname,
                    closureDef=closureDef,
                    closureName="T%s_%s_member_offset" % (classname, cname))
                currentClass.getsetters[truename] = defn
                if pnameflag == "+":
                    closureDef = "const size_t T%s_%s_member_offset = " % \
                                 (classname, pname) + \
                                 PPParser.offsettemplate % vars() + flags + "+0x20000000;"
                    defn = GetSetterDefinition(
                        "getter_orange",
                        (ctype + "::setter") if not readonly else 0, pdesc, cname,
                        closureDef=closureDef,
                        closureName="T%s_%s_member_offset" % (classname, pname))
                    currentClass.getsetters[pname] = defn
                currentClass.references.append(cname)
                return True
            else:
                print("%s(%i): Field '%s' cannot be exported; unsupported type ('%s')" %
                      (self.hppfile, self.lcount + 1, cname, ctype))
            return True
        

    picklingargsdef = re.compile(r'\s*PICKLING_ARGS\s*\((?P<attrs>[^)]*)\)')
    def detectPicklingArgs(self, currentClass, line):
        found = PPParser.picklingargsdef.match(line)
        if found:
            attrs = [x.strip() for x in found.group("attrs").split()]
            if attrs == ["NO_PICKLING"]:
                currentClass.noPickling = True
            else:
                currentClass.picklingArgs = attrs


    constsdef = re.compile(r'\s*PYCLASSCONSTANTS\s*\(\s*(?P<consttype>[<]*\w+)\s*:\s*(?P<constdefs>.*)\)')
    constsdef2 = re.compile(r'\s*enum\s*(?P<consttype>\w+)\s*\{(?P<constdefs>[^}]*)\};?\s*PYCLASSCONSTANTS(?P<goup>_UP)?')
    manualconstantdef = re.compile(r"PYCLASSCONSTANT(?P<consttype>_((FLOAT)|(INT)))?\(\s*(?P<constname>\w*)\s*,\s*(?P<constant>.*)\)\s*;?\s*$")
    def detectConstants(self, currentClass, line):
        found = PPParser.constsdef.match(line)
        sep = ";"
        if not found:
            found = PPParser.constsdef2.match(line)
            sep = ","
        if found and self.checkScope(currentClass, "class constant"):
            try:
                consttype, constdefs = found.group("consttype", "constdefs")
                consttype = consttype.strip()
                if found.group("goup"):
                    consttype = "<" + consttype
                currentClass.constants[consttype] = consts = []
                for cc in constdefs.split(sep):
                    if "=" in cc:
                        k, v = cc.split("=")
                        consts.append((k.strip(), v.strip()))
                    else:
                        consts.append((cc.strip(), len(consts) and int(consts[-1][1]) + 1))
                return True
            except Exception:
                print("%s(%i): Invalid definition of class constants. Ignoring." %
                      (self.hppfile, self.lcount))

        found = PPParser.manualconstantdef.search(line)
        if found and self.checkScope(currentClass, "class constant"):
            consttype, constname, constant = \
                found.group("consttype", "constname", "constant")
            currentClass.constants.setdefault(consttype, []).append((constname, constant))
            return True


    constantdef = re.compile(r"PYMODULECONSTANT\((?P<pyname>\w*)\s*,\s*(?P<ccode>.*)\)\s*$")
    def detectModuleConstants(self, currentClass, line):
        found = PPParser.constantdef.search(line)
        if found:
            pyname, ccode = found.group("pyname", "ccode")
            self.moduleConstants[pyname] = ccode
            return True
            

    modulefunctiondef = re.compile(r'PYMODULEFUNCTION\s+(?P<line>PyObject\s*\*\s*(?P<cname>\w+).*)PYARGS\((?P<argkw>[^),]*)\s*(,\s*"(?P<doc>[^"]*)")?\s*\)')
    def detectModuleFunctions(self, currentClass, line):
        found = PPParser.modulefunctiondef.search(line)
        if found:
            cname, argkw, doc, line = found.group("cname", "argkw", "doc", "line")
            line = line.strip()
            if line[-1] == ";":
                line = line[:-1]
            pyname = cname[3:] if cname.startswith("py_") else cname
            self.moduleFunctions.append(MethodDefinition(pyname, cname, argkw, doc, line + ";\n"))
            return True

            
    specialmethoddef = re.compile(r'(?P<static>static)?\s*(?P<rtype>(T.*)|(PyObject\s*\*)|(int)|(long)|(void)|(Py_ssize_t))\s*__(?P<methodname>%s)__\s*\((?P<args>[^)]*)\)(?P<const>\s*const)?'
                                  % "|".join('(' + m + ')' for m in identifier2slot))
    argdef = re.compile(r'(\w+)(?:,|$)')
    firsttype = re.compile(r'\w+')
    pydocdef = re.compile(r'PYDOC\s*\(\s*"(?P<doc>[^"]*)"\s*\)')
    newnoargs = re.compile(r'\bNEW_NOARGS\b')
    newwithcall = re.compile(r'NEW_WITH_CALL\((?P<base>[^)]*)\)')
    def detectSpecialMethods(self, currentClass, line):
        found = PPParser.specialmethoddef.search(line)
        if found and self.checkScope(currentClass, "special method definition"):
            classname = currentClass.name
            static = bool(found.group("static"))
            methname = found.group("methodname")
            slotname = identifier2slot[methname]
            args = found.group("args")
            firsttype = PPParser.firsttype.search(found.group("args"))
            rtype = found.group("rtype")
            if not args and not static:
                inslotname = "%s__%s__wrapper" % (currentClass.name, methname)
                currentClass.slots[slotname] = inslotname
                if rtype == "void":
                    return_ = tryer = catcher = ""
                else:
                    return_ = "return "
                    tryer = "try {"
                    catcher = "} PyCATCH" if rtype == "PyObject *" else "} PyCATCH_1"
                head = line[:found.start("const")].strip()
                head = head.replace("()", "(PyObject *self)")
                head = head.replace("__%s__" % methname, inslotname).replace(";", "")
                wrapper = "%(head)s { %(tryer)s %(return_)s((T%(classname)s *)&((OrOrange *)self)->orange)->__%(methname)s__(); %(catcher)s }\n\n" % vars()
                currentClass.methodWrappers.append(wrapper)
            elif not static or firsttype and firsttype.group(0)[0] == "P" and \
                               not firsttype.group(0)[1] == "y":
                # similar code is in detectMethods; add any fixed there, too
                firsttype = firsttype.group(0)
                argnames = PPParser.argdef.findall(found.group("args"))
                inslotname = "%s__%s__wrapper" % (currentClass.name, methname)
                currentClass.slots[slotname] = inslotname
                mline = line[found.start("rtype"):found.end()]
                if rtype == "void":
                    return_ = tryer = catcher = ""
                else:
                    return_ = "return "
                    tryer = "try {"
                    catcher = "} PyCATCH" if rtype == "PyObject *" else "} PyCATCH_1"
                if not static:
                    head = line[:found.start("args")] + "PyObject *self, " + \
                           line[found.start("args"):found.end("args") + 1].strip().replace("()", "(PyObject *self)")
                    head = head.strip().replace("__%s__" % methname, inslotname)
                    otherargs = ", ".join(argnames)
                    wrapper = head + "\n{ %(tryer)s %(return_)s ((T%(classname)s *)&((OrOrange *)self)->orange)->__%(methname)s__(%(otherargs)s); %(catcher)s }\n\n" % vars()
                    currentClass.methodWrappers.append(wrapper)
                else:
                    mline = mline.replace(firsttype, "PyObject *")
                    mline = mline.replace("__%s__" % methname, inslotname)
                    firstarg = argnames[0]
                    otherargs = "".join(', ' + x for x in argnames[1:])
                    wrapper = mline + "\n{ %(tryer)s %(return_)sT%(classname)s::__%(methname)s__(%(firsttype)s(%(firstarg)s)%(otherargs)s); %(catcher)s }\n\n" % vars()
                    currentClass.methodWrappers.append(wrapper)
            else:
                if rtype.startswith("TOrange"):
                    if slotname == "tp_new":
                        currentClass.slots["tp_new"] = "%s_newer" % currentClass.name
                    else:
                        print("%s(%i): Method '%s' returns %s *; only 'new' may do this. Ignored." %
                              (self.hppfile, self.lcount, methname, rtype))
                else:
                    currentClass.slots[slotname] = "T%s::__%s__" % (currentClass.name, methname)
                if slotname == "tp_new" and not (rtype.startswith("TOrange") or
                                                 rtype.startswith("PyObject")):
                    print("%s(%i): __new__ should return PyObject * or TOrange *, not '%s'. Ignored." %
                          (self.hppfile, self.lcount, rtype))
            found = PPParser.pydocdef.search(line)
            if found:
                doc = found.group("doc")
                doc2 = self.extractDoc("T%s::__%s__" % (currentClass.name, methname))
                if doc2:
                    doc += "\n\n" + doc2
                currentClass.slotDoc[slotname] = doc
                if slotname in ["tp_new", "tp_call"]:
                    modoc = PPParser.methoddocdef.search(doc)
                    if modoc:
                        if slotname == "tp_new":
                            currentClass.constructorArgs = modoc.group("args")
                        else:
                            currentClass.callArgs = modoc.group("args")
            return True
        found = PPParser.newwithcall.search(line)
        if found:
            currentClass.slots["tp_new"] = "%s_new_with_call" % currentClass.name
            currentClass.callBase = found.group("base")
            return True
        found = PPParser.newnoargs.search(line)
        if found:
            currentClass.slots["tp_new"] = "%s_new_without_args" % currentClass.name
            return True
            

    methoddef = re.compile(r'\A\s*(?P<static>static)?\s*PyObject\s*\*(?P<cname>\w*)\s*\((?P<args>[^)]*)\)(\s*const)?\s*PYARGS\((?P<argkw>[^),]*)\s*(,\s*"(?P<doc>[^"]*)")?\s*\)(\s*//>(?P<methodname>\w\w+))?')
    reducedef = re.compile(r'PyObject\s*\*__reduce__')
    def detectMethods(self, currentClass, line):
        if "PYMODULEFUNCTION" in line:
            return

        found = PPParser.methoddef.match(line)
        if found and self.checkScope(currentClass, "method definition"):
            cname, methodname, argkw, doc = found.group("cname", "methodname", "argkw", "doc")
            static = bool(found.group("static"))
            classname = currentClass.name
            doc2 = self.extractDoc("T%s::%s" % (classname, cname))
            if doc2:
                doc += "\\n\\n" * bool(doc) + doc2
            if not methodname:
                methodname = cname[3:] if cname.startswith("py_") else cname
            args = found.group("args")
            if not args and not static:
                wrappername = "%s_%s_wrapper" % (currentClass.name, methodname)
                head = line[:found.end("args") + 1].strip()\
                    .replace("()", "(PyObject *self)").replace(";", "")\
                    .replace(cname, wrappername)
                currentClass.methods.append(
                    MethodDefinition(methodname or cname, wrappername, argkw, doc,
                        "%(head)s\n{ try { return ((T%(classname)s *)&((OrOrange *)self)->orange)->%(cname)s(); } PyCATCH }\n\n" % vars()))
            else:
                firsttype = PPParser.firsttype.search(args)
                if firsttype and firsttype.group(0)[0] == "T" or not static:
                    # similar code is in detectMethods; add any fixed there, too
                    firsttype = firsttype.group(0)
                    argnames = PPParser.argdef.findall(found.group("args"))
                    wrappername = "%s_%s_wrapper" % (currentClass.name, methodname)
                    if not static:
                        line = (line[:found.start("args")] +
                                "PyObject *self, " +
                                line[found.start("args"):found.end("args") + 1]
                               ).strip()
                        line = line.replace(cname, wrappername)
                        otherargs = ", ".join(argnames)
                        wrapper = line + "\n{ try { return ((T%(classname)s *)&((OrOrange *)self)->orange)->%(cname)s(%(otherargs)s); } PyCATCH }\n\n" % vars()
                    else:
                        line = line[:found.end("args") + 1].strip()
                        line = line.replace(cname, wrappername)
                        line = line.replace(firsttype, "PyObject")
                        firstarg = argnames[0]
                        otherargs = "".join(', ' + x for x in argnames[1:])
                        wrapper = line + "\n{ try { return T%(classname)s::%(cname)s(%(firsttype)s(%(firstarg)s)%(otherargs)s); } PyCATCH }\n\n" % vars()
                    currentClass.methods.append(
                        MethodDefinition(methodname or cname, wrappername,
                                         argkw, doc, wrapper))
                else:
                    currentClass.methods.append(
                        MethodDefinition(methodname or cname,
                                         "T%s::%s" % (classname, cname),
                                         argkw, doc))
            return True

    listdef = re.compile(r'PYVECTOR\((?P<name>\w+)\s*,\s*(?P<wrapped>\w+)\s*(?P<flags>[^)]*)\)')
    listSpecials = ["new", "str", "repr", "richcmp", "len", "concat", "repeat",
                    "item", "ass_item", "contains", "subscript", "ass_subscript"]
    listMethods = [("append", "METH_O"), ("count", "METH_O"), ("extend", "METH_O"), ("index", "METH_O"),
                   ("insert", "METH_VARARGS"), ("pop", "METH_VARARGS"), ("remove", "METH_O"),
                   ("reverse", "METH_NOARGS"), ("sort", "METH_VARARGS"), ("__getnewargs__", "METH_NOARGS")]
    def detectLists(self, currentClass, line):
        found = PPParser.listdef.match(line)
        if found:
            name, wrapped, flags = found.group("name", "wrapped", "flags")
            currentClass = self.classes.get(name, None)
            if not currentClass:
                currentClass = ClassDefinition(name, "Orange", False)
            currentClass.isList = wrapped                
## ADD THIS! (currently there is a memory leak in lists)   IS THIS COMMENT STILL TRUE?
#           if "wrapped" in flags:
#                currentClass.slotDoc.update(dict.fromkeys(["tp_traverse", "tp_clear"], ""))
            for special in PPParser.listSpecials:
                currentClass.slots[identifier2slot[special]] = "T%s::__%s__" % (name, special)
            
            for methodName, argkw in PPParser.listMethods:
                cname = "py_insert" if methodName == "insert" else methodName
                currentClass.methods.append(
                    MethodDefinition(methodName, "T%s::%s" % (name, cname), argkw, ""))
            self.classes[name] = currentClass
            self.classOrder.append(name)
            return True

    
    getdef = re.compile(r'PyObject\s*\*(?P<cname>__(?P<method>get)__(?P<attrname>\w*))\s*\([^)]*\)\s*(PYDOC\(\s*"(?P<doc>[^"]*)"\s*\))?')
    setdef = re.compile(r'int\s*(?P<cname>__(?P<method>set)__(?P<attrname>\w*))\s*\([^)]*\)\s*(PYDOC\(\s*"(?P<doc>[^"]*)"\s*\))?')
    def detectGetSets(self, currentClass, line):
        found = PPParser.getdef.search(line) or PPParser.setdef.search(line)
        if found and self.checkScope(currentClass, "getter/seter definition"):
            cname, attrname, method, doc = found.group("cname", "attrname", "method", "doc")
            getsetdef = currentClass.getsetters.setdefault(
                attrname, GetSetterDefinition(cname=cname))
            if doc:
                getsetdef.doc = doc
            setattr(getsetdef, method + "ter", "T%s::" % currentClass.name + cname)
            if doc:
                getsetdef.doc = doc
            return True


    recognizedattrsdef = re.compile(r'RECOGNIZED_ATTRIBUTES\s*\((?P<attributes>[^"]*)\)')
    def detectRecognizedAttrs(self, currentClass, line):
        found = PPParser.recognizedattrsdef.search(line)
        if found and self.checkScope(currentClass, "list of recognized attributes"):
           attributes = found.group("attributes")
           currentClass.recognizedAttributes.update(x.strip() for x in attributes.split())


    def defineSlots(self, classdef):
        name = classdef.name
        classdef.slots["tp_name"] = '"%s.%s"' % (modulename, name)
        if "tp_call" in classdef.slotDoc:
            classdef.slotDoc["tp_new"] = \
                classdef.slotDoc.get("tp_new", "") + \
                "__call__(...)\\n    " + \
                classdef.slotDoc["tp_call"]
        if "tp_new" in classdef.slotDoc:
            classdef.slots["tp_doc"] = "%s__doc__" % name
        classdef.slots["tp_basicsize"] = "sizeof(Or%s)" % name
        if not classdef.abstract:
            classdef.slots["tp_dealloc"] = "T%s::__dealloc__" % name 
            classdef.slots["tp_traverse"] = "T%s::__traverse__" % name 
            classdef.slots["tp_clear"] = "T%s::__clear__" % name 
        classdef.slots["tp_flags"] = "Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE"
        if "tp_traverse" in classdef.slots:
            classdef.slots["tp_flags"] += " | Py_TPFLAGS_HAVE_GC"
        slotnames = set(classdef.slots)
        
        seqslots = set.intersection(slotnames, specialsequencemethodslots)
        mapslots = set.intersection(slotnames, specialmappingmethodslots)
        # sq_length has to have priority: PySequence_Check uses sq_length and not mp_length
        if seqslots and "sq_length" not in seqslots and "mp_length" in mapslots:
            seqslots.add("sq_length")
            classdef.slots["sq_length"] = classdef.slots["mp_length"]
            del classdef.slots["mp_length"]
            mapslots.remove("mp_length")
        elif len(seqslots) == 1 and "sq_length" in seqslots and mapslots:
            mapslots.add("mp_length")
            seqslots = set()
            classdef.slots["mp_length"] = classdef.slots["sq_length"]
            del classdef.slots["sq_length"]

        if classdef.noPickling:
            classdef.methods.append(
                MethodDefinition(
                    "__getnewargs__",
                    "getnewargs__no_pickling",
                    "METH_NOARGS",
                    "(); class instances cannot be pickled"))
        picklingArgs = getattr(classdef, "picklingArgs", None)
        if picklingArgs:
            classdef.methods.append(
                MethodDefinition(
                    "__getnewargs__",
                    "%s_getnewargs" % classdef.name,
                    "METH_NOARGS",
                    "(); return arguments for __new__"))

        for name, content, condition in [
                ("tp_base", "&Or%s_Type" % classdef.parent, classdef.parent and classdef.parent != "PyObject"),
                ("tp_methods", "%s_methods" % name, classdef.methods),
                ("tp_members", "%s_members" % name, classdef.members),
                ("tp_getset", "%s_getset" % name, classdef.getsetters),
                ("tp_as_number", "&%s_as_number" % name, set.intersection(slotnames, specialnumericmethodslots)),
                ("tp_as_sequence", "&%s_as_sequence" % name, seqslots),
                ("tp_as_mapping", "&%s_as_mapping" % name, mapslots),
                ]:
            if condition:
                classdef.slots[name] = content
        if "len" in classdef.slots and \
           "tp_as_sequence" in classdef.slots and \
           not ("tp_as_sequence" in classdef.slots or "tp_as_mapping" in classdef.slots):
                classdef.slots["tp_as_sequence"] = "%s_as_sequence" % name

        
    def writeSlots(self, px, slots, methodlist):
        for foo, slotname, stype in methodlist:
            content = slots.get(slotname, "0")
            if stype and content != "0":
                content = "(%s)%s" % (stype, content)
            content += ","
            px.write('    %-50s /* %s */\n' % (content, slotname))
        px.write('};\n\n')


    methoddocdef = re.compile(r'^\s*\((?P<args>[^)]*)\)')
    argidentifierdef = re.compile('[A-Za-z0-9_=]+')
    @staticmethod
    def writeKeywords(px, name, arglist):
        args = PPParser.argidentifierdef.findall(arglist)
        args = [x.split("=")[0].strip() for x in args]
        if args:
            px.write('char *%s_keywords[] = {%s, NULL};\n'
                     % (name, ", ".join('"%s"' % x for x in args)))

        
    def writeSpecialKeywords(self, px, classdef):
        consdoc = getattr(classdef, "constructorArgs", None)
        if consdoc:
            self.writeKeywords(px, classdef.name, consdoc)
            px.write("\n")
        consdoc = getattr(classdef, "callArgs", None)
        if consdoc:
            self.writeKeywords(px, classdef.name + "_call", consdoc)

    def writePicklingArgs(self, px, name, classdef):
        picklingArgs = getattr(classdef, "picklingArgs", None)
        if picklingArgs:
            px.write("static char *%s_picklingArgs[] = {%s, NULL};\n" %
                     (name, ", ".join('"%s"' % x for x in picklingArgs)))
            px.write("PyObject *%s_getnewargs(PyObject *self) { return getnewargs_fromList(self, %s_picklingArgs); }\n\n" %
                     (name, name))
        

    @staticmethod
    def writeDocStrings(px, classname, methods, classdoc=None):
        if classdoc:
            px.write('PyDoc_STRVAR(%s__doc__, "%s");\n\n' %
                     (classname, classdoc.replace('\n', '\\n\\\n')))
        for method in methods:
            px.write('PyDoc_STRVAR(%s_%s__doc__, "%s");\n\n' % 
                     (classname, camel2underscore(method.methodname),
                      method.doc.replace('\n', '\\n\\\n')))
            
    @staticmethod
    def writeMethods(px, classname, methods, wrappers):
        if not methods and not wrappers:
            return

        hasKws = False
        if classname != "_module": # module-level kewyords are in .px files
            for method in methods:
                modoc = PPParser.methoddocdef.search(method.doc)
                if modoc:
                    PPParser.writeKeywords(px, classname + "_" + method.methodname,
                                           modoc.group("args"))
                    hasKws = True
            if hasKws:
                px.write('\n')

        if wrappers:
            for m in wrappers:
                px.write(m)
        for method in methods:
            if method.wrapper:
                px.write(method.wrapper)
        px.write('\n')
            
        px.write('static PyMethodDef %s_methods[] = {\n' % classname)
        for method in methods:
            camel = camel2underscore(method.methodname)
            px.write('    {"%s", (PyCFunction)%s, %s, %s_%s__doc__},\n'
                     % (camel, method.cname, method.argkw, classname, camel))
        px.write('    {0}\n};\n\n')

    membertemplate = \
"""    {"%(name)s", %(mtype)s, offsetof(T%(classname)s, %(cname)s)+offsetof(Or%(classname)s, orange), %(flags)s,
     PyDoc_STR("%(doc)s")
    },
"""
    def writeMembers(self, px, classname, members):
        if not members:
            return
        px.write('static PyMemberDef %s_members[] = {\n' % classname)
        for name, mtype, cname, read_only, doc in members:
            px.write(PPParser.membertemplate % {
                        "name": camel2underscore(name),
                        "mtype": mtype,
                        "classname": classname,
                        "cname": cname,
                        "flags": "READONLY" if read_only else "0", "doc": doc})
        px.write('    {0}\n};\n\n')


    offsettemplate = "offsetof(T%(classname)s, %(cname)s)+offsetof(Or%(classname)s, orange)"
    def writeGetsetters(self, px, classname, getsetters):
        if not getsetters:
            return
        for name, getsetter in getsetters.items():
            if getsetter.closureDef:
                px.write(getsetter.closureDef + "\n")
        px.write("\n")

        px.write('PyGetSetDef %s_getset[] = {\n' % classname)
        for pname, getsetter in getsetters.items():
            doc = 'PyDoc_STR("%s")' % getsetter.doc if getsetter.doc else "0"
            if getsetter.closureName:
                closure = "\n     (void *)(&%s)\n" % getsetter.closureName
            else:
                closure = "NULL"
            if getsetter.cname:
                px.write('    {"%(pname)s", (getter)%(getter)s, (setter)%(setter)s,\n     %(doc)s, %(closure)s},\n' % 
                         {"pname": camel2underscore(pname),
                          "getter": getsetter.getter,
                          "setter": getsetter.setter,
                          "doc": doc,
                          "closure": closure})

        px.write('    {0},\n    };\n\n')

    def writeReferencesOffsets(self, px, classname, components):
        px.write('const size_t T%s::%s_referencesOffsets[] = {%s0};\n\n' % (
                      classname, classname,
                      "".join((PPParser.offsettemplate + ", ") %
                              {"classname": classname,
                               "cname": cname} for cname in set(components))))

    def writeConstants(self, px, classname, constants):
        if not constants:
            return
        for consttype, values in constants.items():
            if consttype == "_FLOAT":
                for constname, constvalue in values:
                    px.write("PyObject *%s_Const_%s = PyFloat_FromDouble(%s);"
                        % (classname, constname, constvalue))
            elif consttype == "_INT":
                for constname, constvalue in values:
                    px.write("PyObject *%s_Const_%s = PyLong_FromLong(%s);"
                        % (classname, constname, constvalue))
            elif consttype:
                consttype = re.search("<?(\w*)", consttype).group(1)
                constprefix = classname + "_" + consttype
                typename = constprefix + "_Type"
                px.write(namedConstantType_template % vars())
                for constname, constvalue in values:
                    px.write("struct _longobject %(constprefix)s_%(constname)s_Struct = {PyVarObject_HEAD_INIT(&%(constprefix)s_Type, 1) { %(constvalue)s }};\n"
                             % vars())
                px.write("TNamedConstantsDef %(constprefix)s_constList[] = {\n" % vars())
                for constname, constvalue in values:
                    px.write('    {"%(constname)s", %(constvalue)s, (PyObject *)&%(constprefix)s_%(constname)s_Struct},\n' % vars())
                px.write("    {0}};\n")

        px.write("\n\nvoid %(classname)s_addConstants()\n{\n    if (!Or%(classname)s_Type.tp_dict)\n        Or%(classname)s_Type.tp_dict = PyDict_New();\n" % vars())
        for consttype, values in constants.items():
            if consttype in ("_FLOAT", "_INT") or not consttype:
                for  constname, constvalue in values:
                    px.write('    PyDict_SetItemString(Or%(classname)s_Type.tp_dict, "%(constname)s", %(classname)s_Const_%(constname)s);\n' % vars())
            else:
                direct = "<" in consttype
                consttype = re.search("<?(\w*)", consttype).group(1)
                if direct:
                    for constname, constvalue in values:
                        px.write('    PyDict_SetItemString(Or%(classname)s_Type.tp_dict, "%(constname)s", (PyObject *)&%(classname)s_%(consttype)s_%(constname)s_Struct);\n' % vars());
                px.write('    PyObject *%(consttype)s_module = PyModule_New("%(consttype)s");\n' % vars())
                for constname, constvalue in values:
                    px.write('    PyModule_AddObject(%(consttype)s_module, "%(constname)s", (PyObject *)&%(classname)s_%(consttype)s_%(constname)s_Struct);\n' % vars());
                px.write('    PyDict_SetItemString(Or%(classname)s_Type.tp_dict, "%(consttype)s", %(consttype)s_module);\n' % vars())

        px.write("}\n\n")
        self.headerInitCalls += "%s_addConstants();\n" % classname
    
    def writeInterface(self):
        stem = self.hppfile[:-4]
        ppp = open("ppp/%s.ppp.new" % stem, "wt")
        ppp.write(notice)
        ppp.write('#include "orange.hpp"\n')
        px = open("px/%s.px.new" % stem, "wt")
        px.write(notice)
        hppfile = self.hppfile
        px.write(Px_template_includes % vars())

        for method in self.moduleFunctions:
            if method.doc:
                modoc = PPParser.methoddocdef.search(method.doc)
                if modoc:
                    PPParser.writeKeywords(px, method.methodname, modoc.group("args"))
            
        for classname in self.classOrder:
            classdef = self.classes[classname]
            baseclass = classdef.parent
            inherits = ": public P%s" % classdef.parent if classdef.parent else ""
            ppp.write((P_classTemplate
                       + (P_classTemplate_list_convert
                             if classdef.isList and
                             classdef.isList != "0" and not classdef.isList.endswith("List")
                          else "")
                       + (P_classTemplate_P if not classdef.isList else "")
                       + P_classTemplate_end)
                      % {"classname": classname,
                         "inherits": inherits,
                         "parent": baseclass,
                         "wrapped": classdef.isList}) # , "baseclass": baseclass

            self.defineSlots(classdef)

            if 0: #classdef.parent:
                inhdecref = "T%s::decref_references()" % classdef.parent
                inhtraverse = "T%s::traverse_references(visit, arg)" % classdef.parent
                inhclear = "T%s::clear_references()" % classdef.parent
            else:
                inhdecref = ""
                inhtraverse = inhclear = "0"

            wrapped = classdef.isList
            classname_inpy = "Orange" if classdef.abstract else classname
            if classname != "Orange":
                px.write(Px_template_PyClass % vars())
            if not (classdef.isList or classdef.abstract):
                px.write(Px_template_T_clone % vars())
            if not classdef.isList:
                px.write(Px_template_T % vars())
            if classname not in ["Orange", "ExampleTable"]:
                px.write(Px_template_P % vars())
            if classdef.isList and classdef.isList != "0":
                px.write(Px_template_list_convert % vars())

            self.writeSpecialKeywords(px, classdef)
            if classdef.slots.get("tp_new", "").endswith("newer"):
                keywords = classname + "_keywords" if hasattr(classdef, "constructorArgs") else "NULL"
                px.write(Px_template_newer % vars())
            elif classdef.slots.get("tp_new", "").endswith("_new_without_args"):
                px.write(Px_template_new_without_args % vars())
            if classdef.slots.get("tp_new", "").endswith("_new_with_call"):
                callBase = classdef.callBase
                px.write(Px_template_new_with_call % vars())

            self.writePicklingArgs(px, classname, classdef)
            self.writeDocStrings(px, classname, classdef.methods, classdef.slotDoc.get("tp_new", None))
            self.writeMethods(px, classname, classdef.methods, classdef.methodWrappers)
            self.writeMembers(px, classname, classdef.members)
            self.writeGetsetters(px, classname, classdef.getsetters)
#            if not classdef.isList:
#                self.writeReferencesOffsets(px, classname, classdef.references)
            self.writeConstants(px, classname, classdef.constants)

            for suitetype, methods, suitesuffix in [
                ('PyNumberMethods', specialnumericmethods, '_as_number'),
                ('PySequenceMethods', specialsequencemethods, '_as_sequence'),
                ('PyMappingMethods', specialmappingmethods, '_as_mapping')]:
                if "tp" + suitesuffix in classdef.slots:
                    px.write('%s %s%s = {\n' % (suitetype, classname, suitesuffix))
                    self.writeSlots(px, classdef.slots, methods)

            if "tp_base" in classdef.slots:
                px.write("extern PyTypeObject %s;\n\n" % classdef.slots["tp_base"][1:])
                
            px.write('PyTypeObject Or%s_Type = {\n' % classname)
            px.write('    PyObject_HEAD_INIT((_typeobject *)&PyType_Type)\n')
            self.writeSlots(px, classdef.slots, specialmethods)

        if self.headerInitCalls:
            px.write("void %s_init(PyObject *module)\n{ %s}\n" % (stem, self.headerInitCalls))
            self.needsInit = True
            
        renew(ppp)
        renew(px)

    def saveModuleData(self):
        if os.path.exists("px/init-data.pickle"):
            moduleData = pickle.load(open("px/init-data.pickle", "rb"))
        else:
            moduleData = {}
        moduleData[hppfile] = myData = ModuleData()
        myData.classes = list(self.classes)
        myData.needsInit = self.needsInit
        myData.moduleConstants = self.moduleConstants
        myData.moduleFunctions = self.moduleFunctions
        pickle.dump(moduleData, open("px/init-data.pickle", "wb"))
        
    @staticmethod
    def writeModuleInit():
        if os.path.exists("px/init-data.pickle"):
            moduleData = pickle.load(open("px/init-data.pickle", "rb"))
        else:
            moduleData = {}

        initfile = open("px/initialization.px.new", "wt")
        initfile.write(notice)

        allMethods = []
        for module in moduleData.values():
            for classname in module.classes:
                initfile.write("extern PyTypeObject Or%s_Type;\n" % classname)
            allMethods += module.moduleFunctions
        initfile.write("\n")

        PPParser.writeDocStrings(initfile, "_module", allMethods)
        PPParser.writeMethods(initfile, "_module", allMethods, [])
            
        initfile.write("bool addObjects(PyObject *module)\n{\n")
        for module in moduleData.values():
            for classname in module.classes:
                initfile.write('    if (PyType_Ready(&Or%s_Type) == -1) return NULL;\n' % classname)
                initfile.write('    Py_INCREF((PyObject *)&Or%s_Type);\n' % classname)
                initfile.write('    if (PyModule_AddObject(module, "%s", (PyObject *)&Or%s_Type) == -1) return NULL;\n' % (classname, classname))
        for module in moduleData.values():
            for cc in module.moduleConstants.items():
                initfile.write('    if (PyModule_AddObject(module, "%s", %s) == -1) return NULL;\n' % cc)
        
        
        initfile.write("    return true; }\n\n")

        for name, module in moduleData.items():
            if module.needsInit:
                initfile.write("void %s_init(PyObject *);\n" % name[:-4])

        initfile.write("void header_inits(PyObject *module)\n{\n")
        for name, module in moduleData.items():
            if module.needsInit:
                initfile.write('    %s_init(module);\n' % name[:-4])
        initfile.write("}\n\n")
                
        initfile.write(init_template % {
            "modulename" : "orange",
            "MODULENAME": "ORANGE",
            "methods": "_module_methods" if allMethods else "0"})
        renew(initfile)
    

def update_doxy(allfiles):
    if not os.path.exists("doc\orange-doxy.conf"):
        return
    g = open("doc\orange-doxy.conf.new", "w")
    for line in open("doc\orange-doxy.conf", "r"):
        if line.startswith("INPUT "):
            line = "INPUT = "+" ".join(allfiles) + "\n"
        g.write(line)
    renew(g)

def update_aliases():
    aliases = []
    for line in open("_aliases.txt"):
        line = line.strip().split()
        if len(line) == 1:
            aliases.append([line[0], []])
        elif line:
            aliases[-1][-1].append(line)

    px = open("px/alias_attributes.px.new", "wt")
    px.write("\n".join("extern PyTypeObject Or%s_Type;" % c[0] for c in aliases))
    px.write("\n\nchar const *translateAttributeName(PyObject *self, char const *const name)\n{\n")
    for cls, renames in aliases:
        px.write('    if (PyObject_IsInstance(self, (PyObject *)&Or%s_Type)) {\n' % cls)
        px.write("".join('        if (!strcmp(name, "%s")) return "%s";\n' %
                         tuple(r) for r in renames))
        px.write("    }\n")
    px.write("    return NULL;\n}\n")
    px.close()
    renew(px)

if __name__ == "__main__":
    import xml.dom.minidom
    modulename = "orange"
    vcproj = xml.dom.minidom.parse(open("Orange.vcxproj", encoding="utf8"))
    files = vcproj.getElementsByTagName("ClInclude") + \
            vcproj.getElementsByTagName("CustomBuildStep")
    for fle in files:
        rpath = fle.getAttribute("Include")
#        try:
#            conf = fle.getElementsByTagName("FileConfiguration")[0]
#            if conf.getAttribute("ExcludedFromBuild") == "true":
#                continue
#        except:
#            pass
        if "\\" in rpath or "/" in rpath:
            continue
#        rpath = rpath.replace("\\", "/")
        hppfile = os.path.split(rpath)[1]
        if not hppfile.endswith(".hpp") or \
           not os.path.exists(hppfile) or \
           hppfile.endswith("pyxtract_macros.hpp"):
               continue
        parser = PPParser(hppfile)
        parser.parse()
        parser.writeInterface()
        parser.saveModuleData()
    parser.writeModuleInit()

    allfiles = set()
    for tpe in ("ClInclude", "ClCompile", "CustomBuildStep"):
        for fle in vcproj.getElementsByTagName(tpe):
            rpath = fle.getAttribute("Include").strip()
            if not rpath or "\\" in rpath or "/" in rpath:
                continue
            allfiles.add("../"+rpath)
    update_doxy(allfiles)

    update_aliases()